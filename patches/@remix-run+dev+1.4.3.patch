diff --git a/node_modules/@remix-run/dev/compiler.js b/node_modules/@remix-run/dev/compiler.js
index 902b251..884c52d 100644
--- a/node_modules/@remix-run/dev/compiler.js
+++ b/node_modules/@remix-run/dev/compiler.js
@@ -28,13 +28,16 @@ var loaders = require('./compiler/loaders.js');
 var browserRouteModulesPlugin = require('./compiler/plugins/browserRouteModulesPlugin.js');
 var emptyModulesPlugin = require('./compiler/plugins/emptyModulesPlugin.js');
 var mdx = require('./compiler/plugins/mdx.js');
+var nativeNodeModules = require('./compiler/plugins/nativeNodeModules.js');
+var wasm = require('./compiler/plugins/wasmPlugin.js');
+
 var serverAssetsManifestPlugin = require('./compiler/plugins/serverAssetsManifestPlugin.js');
 var serverBareModulesPlugin = require('./compiler/plugins/serverBareModulesPlugin.js');
 var serverEntryModulePlugin = require('./compiler/plugins/serverEntryModulePlugin.js');
 var serverRouteModulesPlugin = require('./compiler/plugins/serverRouteModulesPlugin.js');
 var fs = require('./compiler/utils/fs.js');
 
-function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }
+function _interopDefaultLegacy(e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }
 
 function _interopNamespace(e) {
   if (e && e.__esModule) return e;
@@ -247,7 +250,7 @@ async function watch(config$1, {
     }
   });
   return async () => {
-    await watcher.close().catch(() => {});
+    await watcher.close().catch(() => { });
     disposeBuilders();
   };
 }
@@ -289,7 +292,10 @@ async function createBrowserBuild(config, options) {
   // this is really just making sure we don't accidentally have any dependencies
   // on node built-ins in browser bundles.
   let dependencies$1 = Object.keys(dependencies.getAppDependencies(config));
+  console.log("Dependencies:", dependencies$1);
   let externals = module$1.builtinModules.filter(mod => !dependencies$1.includes(mod));
+  externals.push("browser-rust-functions")
+  console.log("Externals", externals);
   let fakeBuiltins = module$1.builtinModules.filter(mod => dependencies$1.includes(mod));
 
   if (fakeBuiltins.length > 0) {
@@ -320,6 +326,8 @@ async function createBrowserBuild(config, options) {
     }));
   }
 
+  console.log("Output directory:", config.assetsBuildDirectory);
+
   return esbuild__namespace.build({
     entryPoints,
     outdir: config.assetsBuildDirectory,
@@ -370,6 +378,10 @@ function createServerBuild(config, options, assetsManifestPromiseRef) {
   if (config.serverPlatform !== "node") {
     plugins.unshift(nodeModulesPolyfill.NodeModulesPolyfillPlugin());
   }
+  if (config.serverPlatform == "node") {
+    plugins.unshift(nativeNodeModules.nativeNodeModulesPlugin());
+  }
+
 
   return esbuild__namespace.build({
     absWorkingDir: config.rootDirectory,
@@ -387,7 +399,7 @@ function createServerBuild(config, options, assetsManifestPromiseRef) {
     inject: config.serverBuildTarget === "deno" ? [] : [reactShim],
     loader: loaders.loaders,
     bundle: true,
-    logLevel: "silent",
+    // logLevel: "silent",
     incremental: options.incremental,
     sourcemap: options.sourcemap,
     // use linked (true) to fix up .map file
@@ -431,6 +443,26 @@ async function writeServerBuildResult(config, outputFiles) {
       let contents = Buffer.from(file.contents).toString("utf-8");
       contents = contents.replace(/"route:/gm, '"');
       await fse__namespace.writeFile(file.path, contents);
+    } else if (file.path.endsWith(".node")) {
+      // Check for and make _assets folder if it does not exist in the directory
+      // I suspect this is usually done elsewhere
+      let parentFolderPath = file.path.slice(0, file.path.lastIndexOf("/"))
+      if (!fse.existsSync(parentFolderPath)) {
+        fse.mkdirSync(parentFolderPath, { recursive: true });
+      }
+
+      // Write the binary .node file to the same path and with the same contents as expected
+      await fse__namespace.writeFile(file.path, file.contents)
+    } else if (file.path.endsWith(".wasm")) {
+      // Check for and make _assets folder if it does not exist in the directory
+      // I suspect this is usually done elsewhere
+      let parentFolderPath = file.path.slice(0, file.path.lastIndexOf("/"))
+      if (!fse.existsSync(parentFolderPath)) {
+        fse.mkdirSync(parentFolderPath, { recursive: true });
+      }
+
+      // Write the binary .wasm file to the same path and with the same contents as expected
+      await fse__namespace.writeFile(file.path, file.contents)
     }
   }
 }
diff --git a/node_modules/@remix-run/dev/compiler/loaders.js b/node_modules/@remix-run/dev/compiler/loaders.js
index 6d4fc65..73cbd82 100644
--- a/node_modules/@remix-run/dev/compiler/loaders.js
+++ b/node_modules/@remix-run/dev/compiler/loaders.js
@@ -60,6 +60,7 @@ const loaders = {
   ".tsx": "tsx",
   ".ttf": "file",
   ".wav": "file",
+  ".wasm": "file",
   ".webm": "file",
   ".webp": "file",
   ".woff": "file",
diff --git a/node_modules/@remix-run/dev/compiler/plugins/mdx.js b/node_modules/@remix-run/dev/compiler/plugins/mdx.js
index 8d34c2a..cc57218 100644
--- a/node_modules/@remix-run/dev/compiler/plugins/mdx.js
+++ b/node_modules/@remix-run/dev/compiler/plugins/mdx.js
@@ -58,8 +58,8 @@ function mdxPlugin(config) {
 
           return matchPath(id, undefined, undefined, [".ts", ".tsx", ".js", ".jsx", ".mdx", ".md"]) || id;
         }
-
         let resolvedPath = resolvePath(args.path);
+  
         let resolved = path__namespace.resolve(args.resolveDir, resolvedPath);
         return {
           path: resolved,
diff --git a/node_modules/@remix-run/dev/compiler/plugins/nativeNodeModules.d.ts b/node_modules/@remix-run/dev/compiler/plugins/nativeNodeModules.d.ts
new file mode 100644
index 0000000..d51dc9b
--- /dev/null
+++ b/node_modules/@remix-run/dev/compiler/plugins/nativeNodeModules.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from "esbuild";
+export declare function nativeNodeModulesPlugin(): Plugin;
\ No newline at end of file
diff --git a/node_modules/@remix-run/dev/compiler/plugins/nativeNodeModules.js b/node_modules/@remix-run/dev/compiler/plugins/nativeNodeModules.js
new file mode 100644
index 0000000..f5b1d05
--- /dev/null
+++ b/node_modules/@remix-run/dev/compiler/plugins/nativeNodeModules.js
@@ -0,0 +1,96 @@
+/**
+ * @remix-run/dev v1.4.3
+ *
+ * Copyright (c) Remix Software Inc.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE.md file in the root directory of this source tree.
+ *
+ * @license MIT
+ */
+'use strict';
+
+Object.defineProperty(exports, '__esModule', { value: true });
+var path = require('path');
+
+function _interopNamespace(e) {
+    if (e && e.__esModule) return e;
+    var n = Object.create(null);
+    if (e) {
+      Object.keys(e).forEach(function (k) {
+        if (k !== 'default') {
+          var d = Object.getOwnPropertyDescriptor(e, k);
+          Object.defineProperty(n, k, d.get ? d : {
+            enumerable: true,
+            get: function () { return e[k]; }
+          });
+        }
+      });
+    }
+    n["default"] = e;
+    return Object.freeze(n);
+  }
+
+var path__namespace = /*#__PURE__*/_interopNamespace(path);
+
+function nativeNodeModulesPlugin() {
+  return {
+    name: "native-node-modules",
+
+    setup(build) {
+      // If a ".node" file is imported within a module in the "file" namespace, resolve
+      // it to an absolute path and put it into the "node-file" virtual namespace.
+      build.onResolve({
+        filter: /\.node$/,
+        namespace: "file"
+      }, args => {
+        // Let's convert the path to an absolute path.
+        let resolved = path__namespace.resolve(args.resolveDir, args.path)
+      return (
+          {
+        path: resolved,
+        namespace: "node-file"
+      }
+      )}); // Files in the "node-file" virtual namespace call "require()" on the
+      // path from esbuild of the ".node" file in the output directory.
+
+      build.onLoad({
+        filter: /.*/,
+        namespace: "node-file"
+      }, args => {
+        let projectRoot = path.resolve();
+        return ({
+        contents: `
+        import * as path from "path";
+        import modulePath from ${JSON.stringify(args.path)}
+
+        let projectRoot = "${path__namespace.resolve()}";
+        let absolutePath = path.join(projectRoot, modulePath);
+
+        try { module.exports = require(absolutePath); 
+    }
+        catch (error) {
+            console.log("Node Module Loading Error:", error)
+        }
+      `
+      })}); // If a ".node" file is imported within a module in the "node-file" namespace, put
+      // it in the "file" namespace where esbuild's default loading behavior will handle
+      // it. It is already an absolute path since we resolved it to one above.
+
+      build.onResolve({
+        filter: /\.node$/,
+        namespace: "node-file"
+      }, args => ({
+        path: args.path,
+        namespace: "file"
+      })); // Tell esbuild's default loading behavior to use the "file" loader for
+      // these ".node" files.
+
+      let opts = build.initialOptions;
+      opts.loader = opts.loader || {};
+      opts.loader[".node"] = "file";
+    }
+
+  };
+}
+exports.nativeNodeModulesPlugin = nativeNodeModulesPlugin;
diff --git a/node_modules/@remix-run/dev/compiler/plugins/serverBareModulesPlugin.js b/node_modules/@remix-run/dev/compiler/plugins/serverBareModulesPlugin.js
index 804e722..fdd3e17 100644
--- a/node_modules/@remix-run/dev/compiler/plugins/serverBareModulesPlugin.js
+++ b/node_modules/@remix-run/dev/compiler/plugins/serverBareModulesPlugin.js
@@ -18,7 +18,7 @@ var module$1 = require('module');
 var virtualModules = require('../virtualModules.js');
 var index = require('../utils/tsconfig/index.js');
 
-function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }
+function _interopDefaultLegacy(e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }
 
 var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
 var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
diff --git a/node_modules/@remix-run/dev/compiler/plugins/wasmPlugin.d.ts b/node_modules/@remix-run/dev/compiler/plugins/wasmPlugin.d.ts
new file mode 100644
index 0000000..2909452
--- /dev/null
+++ b/node_modules/@remix-run/dev/compiler/plugins/wasmPlugin.d.ts
@@ -0,0 +1,2 @@
+import type { Plugin } from "esbuild";
+export declare function wasmPlugin(): Plugin;
\ No newline at end of file
diff --git a/node_modules/@remix-run/dev/compiler/plugins/wasmPlugin.js b/node_modules/@remix-run/dev/compiler/plugins/wasmPlugin.js
new file mode 100644
index 0000000..89c1407
--- /dev/null
+++ b/node_modules/@remix-run/dev/compiler/plugins/wasmPlugin.js
@@ -0,0 +1,130 @@
+// // /**
+// //  * @remix-run/dev v1.4.3
+// //  *
+// //  * Copyright (c) Remix Software Inc.
+// //  *
+// //  * This source code is licensed under the MIT license found in the
+// //  * LICENSE.md file in the root directory of this source tree.
+// //  *
+// //  * @license MIT
+// //  */
+// // 'use strict';
+
+// Object.defineProperty(exports, '__esModule', { value: true });
+// var path = require('path');
+
+// function _interopNamespace(e) {
+//     if (e && e.__esModule) return e;
+//     var n = Object.create(null);
+//     if (e) {
+//         Object.keys(e).forEach(function (k) {
+//             if (k !== 'default') {
+//                 var d = Object.getOwnPropertyDescriptor(e, k);
+//                 Object.defineProperty(n, k, d.get ? d : {
+//                     enumerable: true,
+//                     get: function () { return e[k]; }
+//                 });
+//             }
+//         });
+//     }
+//     n["default"] = e;
+//     return Object.freeze(n);
+// }
+
+// var path__namespace = /*#__PURE__*/_interopNamespace(path);
+
+// function wasmPlugin() {
+//     return {
+//         name: "wasm",
+
+//         setup(build) {
+//             // If a ".wasm" file is imported within a module in the "file" namespace, resolve
+//             // it to an absolute path and put it into the "node-file" virtual namespace.
+//             build.onResolve({
+//                 filter: /\.wasm$/,
+//                 namespace: "file"
+//             }, args => {
+//                 // Let's convert the path to an absolute path.
+//                 let resolved = path__namespace.resolve(args.resolveDir, args.path)
+//                 console.log("Resolved", resolved)
+//                 return (
+//                     {
+//                         path: resolved,
+//                         namespace: "wasm-file"
+//                     }
+//                 )
+//             }); // Files in the "node-file" virtual namespace call "require()" on the
+//             // path from esbuild of the ".wasm" file in the output directory.
+
+//             build.onLoad({
+//                 filter: /.*/,
+//                 namespace: "wasm-file"
+//             }, args => {
+//                 let projectRoot = path.resolve();
+//                 return ({
+//                     contents: `
+//                  import * as path from "path";
+//                  import modulePath from ${JSON.stringify(args.path)}
+//                 console.log("modulePath", modulePath);
+//                  let projectRoot = "${path__namespace.resolve()}";
+//                  let absolutePath = path.join(projectRoot, modulePath);
+
+//                  try { module.exports = require(absolutePath); 
+//              }
+//                  catch (error) {
+//                      console.log("Node Module Loading Error:", error)
+//                  }
+//                `
+//                 })
+//             }); // If a ".wasm" file is imported within a module in the "node-file" namespace, put
+//             // it in the "file" namespace where esbuild's default loading behavior will handle
+//             // it. It is already an absolute path since we resolved it to one above.
+
+//             build.onResolve({
+//                 filter: /\.wasm$/,
+//                 namespace: "wasm-file"
+//             }, args => ({
+//                 path: args.path,
+//                 namespace: "file"
+//             })); // Tell esbuild's default loading behavior to use the "file" loader for
+//             // these ".wasm" files.
+
+//             let opts = build.initialOptions;
+//             opts.loader = opts.loader || {};
+//             opts.loader[".wasm"] = "file";
+//         }
+
+//     };
+// }
+// exports.wasmPlugin = wasmPlugin;
+
+// // function wasmPlugin() {
+// //     return {
+// //         name: 'wasm',
+// //         setup(build) {
+// //             let path = require('path')
+// //             let fs = require('fs')
+
+// //             // Resolve ".wasm" files to a path with a namespace
+// //             build.onResolve({ filter: /\.wasm$/ }, args => {
+// //                 if (args.resolveDir === '') {
+// //                     return // Ignore unresolvable paths
+// //                 }
+// //                 return {
+// //                     path: path.isAbsolute(args.path) ? args.path : path.join(args.resolveDir, args.path),
+// //                     namespace: 'wasm-binary',
+// //                 }
+// //             })
+
+// //             // Virtual modules in the "wasm-binary" namespace contain the
+// //             // actual bytes of the WebAssembly file. This uses esbuild's
+// //             // built-in "binary" loader instead of manually embedding the
+// //             // binary data inside JavaScript code ourselves.
+// //             build.onLoad({ filter: /.*/, namespace: 'wasm-binary' }, async (args) => ({
+// //                 contents: await fs.promises.readFile(args.path),
+// //                 loader: 'binary',
+// //             }))
+// //         },
+// //     }
+// // }
+// // exports.wasmPlugin = wasmPlugin;
\ No newline at end of file
